// Generated by delombok at Fri Nov 04 22:13:55 CST 2022
package org.mineacademy.fo.database;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLSyntaxErrorException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;
import org.mineacademy.fo.Common;
import org.mineacademy.fo.FileUtil;
import org.mineacademy.fo.ReflectionUtil;
import org.mineacademy.fo.SerializeUtil;
import org.mineacademy.fo.SerializeUtil.Mode;
import org.mineacademy.fo.TimeUtil;
import org.mineacademy.fo.Valid;
import org.mineacademy.fo.collection.SerializedMap;
import org.mineacademy.fo.collection.StrictMap;
import org.mineacademy.fo.debug.Debugger;
import org.mineacademy.fo.exception.FoException;
import org.mineacademy.fo.model.ConfigSerializable;
import org.mineacademy.fo.remain.Remain;
import lombok.NonNull;

/**
 * Represents a simple MySQL database
 * <p>
 * Before running queries make sure to call connect() methods.
 * <p>
 * You can also override onConnected() to run your code after the
 * connection has been established.
 * <p>
 * To use this class you must know the MySQL command syntax!
 */
public class SimpleDatabase {
	/**
	 * The established connection, or null if none
	 */
	private volatile Connection connection;
	/**
	 * Map of variables you can use with the {} syntax in SQL
	 */
	private final StrictMap<String, String> sqlVariables = new StrictMap<>();
	/**
	 * The raw URL from which the connection was created
	 */
	private String url;
	/**
	 * The last credentials from the connect function, or null if never called
	 */
	private LastCredentials lastCredentials;
	/**
	 * Private indicator that we are connecting to database right now
	 */
	private boolean connecting = false;
	/**
	 * Optional Hikari data source (you plugin needs to include com.zaxxer.HikariCP library in its plugin.yml (MC 1.16+ required)
	 */
	private Object hikariDataSource;

	// --------------------------------------------------------------------
	// Connecting
	// --------------------------------------------------------------------
	/**
	 * Attempts to establish a new database connection
	 *
	 * @param host
	 * @param port
	 * @param database
	 * @param user
	 * @param password
	 */
	public final void connect(final String host, final int port, final String database, final String user, final String password) {
		this.connect(host, port, database, user, password, null);
	}

	/**
	 * Attempts to establish a new database connection,
	 * you can then use {table} in SQL to replace with your table name
	 *
	 * @param host
	 * @param port
	 * @param database
	 * @param user
	 * @param password
	 * @param table
	 */
	public final void connect(final String host, final int port, final String database, final String user, final String password, final String table) {
		this.connect(host, port, database, user, password, table, true);
	}

	/**
	 * Attempts to establish a new database connection
	 * you can then use {table} in SQL to replace with your table name
	 *
	 * @param host
	 * @param port
	 * @param database
	 * @param user
	 * @param password
	 * @param table
	 * @param autoReconnect
	 */
	public final void connect(final String host, final int port, final String database, final String user, final String password, final String table, final boolean autoReconnect) {
		this.connect("jdbc:mysql://" + host + ":" + port + "/" + database + "?useSSL=false&useUnicode=yes&characterEncoding=UTF-8&autoReconnect=" + autoReconnect, user, password, table);
	}

	/**
	 * Connects to the database.
	 *
	 * WARNING: Requires a database type NOT needing a username nor a password!
	 *
	 * @param url
	 */
	public final void connect(final String url) {
		this.connect(url, null, null);
	}

	/**
	 * Connects to the database
	 *
	 * @param url
	 * @param user
	 * @param password
	 */
	public final void connect(final String url, final String user, final String password) {
		this.connect(url, user, password, null);
	}

	/**
	 * Connects to the database
	 * you can then use {table} in SQL to replace with your table name*
	 *
	 * @param url
	 * @param user
	 * @param password
	 * @param table
	 */
	public final void connect(final String url, final String user, final String password, final String table) {
		this.url = url;
		this.connecting = true;
		try {
			// Support local storage of databases on your disk, typically in your plugin's folder
			// Make sure to load the library using "libraries" and "legacy-libraries" feature in plugin.yml:
			//
			// libraries:
			// - org.xerial:sqlite-jdbc:3.36.0.3
			//
			// legacy-libraries:
			// - org.xerial:sqlite-jdbc:3.36.0.3
			//
			if (url.startsWith("jdbc:sqlite")) {
				Class.forName("org.sqlite.JDBC");
				this.connection = DriverManager.getConnection(url);
			} else 
			// Avoid using imports so that Foundation users don't have to include Hikari, you can
			// optionally load the library using "libraries" and "legacy-libraries" feature in plugin.yml:
			//
			// libraries:
			// - com.zaxxer:HikariCP:5.0.1
			// legacy-libraries:
			//  - org.slf4j:slf4j-simple:1.7.36
			//  - org.slf4j:slf4j-api:1.7.36
			//  - com.zaxxer:HikariCP:4.0.3
			//
			if (ReflectionUtil.isClassAvailable("com.zaxxer.hikari.HikariConfig")) {
				final Object hikariConfig = ReflectionUtil.instantiate("com.zaxxer.hikari.HikariConfig");
				if (url.startsWith("jdbc:mysql://")) try {
					ReflectionUtil.invoke("setDriverClassName", hikariConfig, "com.mysql.cj.jdbc.Driver");
				} catch (final Throwable t) {
					// Fall back to legacy driver
					ReflectionUtil.invoke("setDriverClassName", hikariConfig, "com.mysql.jdbc.Driver");
				}
				 else if (url.startsWith("jdbc:mariadb://")) ReflectionUtil.invoke("setDriverClassName", hikariConfig, "org.mariadb.jdbc.Driver");
				 else throw new FoException("Unknown database driver, expected jdbc:mysql or jdbc:mariadb, got: " + url);
				ReflectionUtil.invoke("setJdbcUrl", hikariConfig, url);
				if (user != null) ReflectionUtil.invoke("setUsername", hikariConfig, user);
				if (password != null) ReflectionUtil.invoke("setPassword", hikariConfig, password);
				final Constructor<?> dataSourceConst = ReflectionUtil.getConstructor("com.zaxxer.hikari.HikariDataSource", hikariConfig.getClass());
				final Object hikariSource = ReflectionUtil.instantiate(dataSourceConst, hikariConfig);
				this.hikariDataSource = hikariSource;
				final Method getConnection = hikariSource.getClass().getDeclaredMethod("getConnection");
				try {
					this.connection = ReflectionUtil.invoke(getConnection, hikariSource);
				} catch (final Throwable t) {
					Common.warning("Could not get HikariCP connection, please report this with the information below to github.com/kangarko/foundation");
					Common.warning("Method: " + getConnection);
					Common.warning("Arguments: " + Common.join(getConnection.getParameters()));
					t.printStackTrace();
				}
			} else 
			/*
			 * Check for JDBC Drivers (MariaDB, MySQL or Legacy MySQL)
			 */
			{
				if (url.startsWith("jdbc:mariadb://") && ReflectionUtil.isClassAvailable("org.mariadb.jdbc.Driver")) Class.forName("org.mariadb.jdbc.Driver");
				 else if (url.startsWith("jdbc:mysql://") && ReflectionUtil.isClassAvailable("com.mysql.cj.jdbc.Driver")) Class.forName("com.mysql.cj.jdbc.Driver");
				 else {
					Common.warning("Your database driver is outdated, switching to MySQL legacy JDBC Driver. If you encounter issues, consider updating your database or switching to MariaDB. You can safely ignore this warning");
					Class.forName("com.mysql.jdbc.Driver");
				}
				this.connection = user != null && password != null ? DriverManager.getConnection(url, user, password) : DriverManager.getConnection(url);
			}
			this.lastCredentials = new LastCredentials(url, user, password, table);
			this.onConnected();
		} catch (final Exception ex) {
			if (Common.getOrEmpty(ex.getMessage()).contains("No suitable driver found")) Common.logFramed(true, "Failed to look up database driver! If you had database disabled,", "then enable it and reload - this is expected.", "", "You have have access to your server machine, try installing", "https://mariadb.com/downloads/connectors/connectors-data-access/", "", "If this problem persists after a restart, please contact", "your hosting provider with the error message below.");
			 else Common.logFramed(true, "Failed to connect to database", "URL: " + url, "Error: " + ex.getMessage());
			Remain.sneaky(ex);
		} finally {
			this.connecting = false;
		}
	}

	/**
	 * Attempts to connect using last known credentials. Fails gracefully if those are not provided
	 * i.e. connect function was never called
	 */
	protected final void connectUsingLastCredentials() {
		if (this.lastCredentials != null) this.connect(this.lastCredentials.url, this.lastCredentials.user, this.lastCredentials.password, this.lastCredentials.table);
	}

	/**
	 * Called automatically after the first connection has been established
	 */
	protected void onConnected() {
	}

	// --------------------------------------------------------------------
	// Disconnecting
	// --------------------------------------------------------------------
	/**
	 * Attempts to close the result set if not
	 *
	 * @param resultSet
	 */
	public final void close(ResultSet resultSet) {
		try {
			if (!resultSet.isClosed()) resultSet.close();
		} catch (final SQLException e) {
			Common.error(e, "Error closing database result set!");
		}
	}

	/**
	 * Attempts to close the connection, if not null
	 */
	public final void close() {
		try {
			if (this.connection != null) this.connection.close();
			if (this.hikariDataSource != null) ReflectionUtil.invoke("close", this.hikariDataSource);
		} catch (final SQLException e) {
			Common.error(e, "Error closing database connection!");
		}
	}

	// --------------------------------------------------------------------
	// Querying
	// --------------------------------------------------------------------
	/**
	 * Creates a database table, to be used in onConnected
	 *
	 * @param creator
	 */
	protected final void createTable(TableCreator creator) {
		String columns = "";
		for (final TableRow column : creator.getColumns()) {
			columns += (columns.isEmpty() ? "" : ", ") + "`" + column.getName() + "` " + column.getDataType();
			if (column.getAutoIncrement() != null && column.getAutoIncrement()) columns += " NOT NULL AUTO_INCREMENT";
			 else if (column.getNotNull() != null && column.getNotNull()) columns += " NOT NULL";
			if (column.getDefaultValue() != null) columns += " DEFAULT " + column.getDefaultValue();
		}
		if (creator.getPrimaryColumn() != null) columns += ", PRIMARY KEY (`" + creator.getPrimaryColumn() + "`)";
		try {
			final boolean isSQLite = this.url != null && this.url.startsWith("jdbc:sqlite");
			this.update("CREATE TABLE IF NOT EXISTS `" + creator.getName() + "` (" + columns + ")" + (isSQLite ? "" : " DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci") + ";");
		} catch (final Throwable t) {
			if (t.toString().contains("Unknown collation")) {
				Common.log("You need to update your database driver to support utf8mb4_unicode_520_ci collation. We switched to support unicode using 4 bits length because the previous system only supported 3 bits.");
				Common.log("Some characters such as smiley or Chinese are stored in 4 bits so they would crash the 3-bit database leading to more problems. Most hosting providers have now widely adopted the utf8mb4_unicode_520_ci encoding you seem lacking. Disable database connection or update your driver to fix this.");
			} else throw t;
		}
	}

	/**
	 * Insert the given column-values pairs into the {@link #getTable()}
	 *
	 * @param columsAndValues
	 */
	protected final void insert(@NonNull SerializedMap columsAndValues) {
		if (columsAndValues == null) {
			throw new java.lang.NullPointerException("columsAndValues is marked non-null but is null");
		}
		this.insert("{table}", columsAndValues);
	}

	/**
	 * Insert the given serializable object as its column-value pairs into the given table
	 *
	 * @param <T>
	 * @param table
	 * @param serializableObject
	 */
	protected final <T extends ConfigSerializable> void insert(String table, @NonNull T serializableObject) {
		if (serializableObject == null) {
			throw new java.lang.NullPointerException("serializableObject is marked non-null but is null");
		}
		this.insert(table, serializableObject.serialize());
	}

	/**
	 * Insert the given column-values pairs into the given table
	 *
	 * @param table
	 * @param columsAndValues
	 */
	protected final void insert(String table, @NonNull SerializedMap columsAndValues) {
		if (columsAndValues == null) {
			throw new java.lang.NullPointerException("columsAndValues is marked non-null but is null");
		}
		final String columns = Common.join(columsAndValues.keySet());
		final String values = Common.join(columsAndValues.values(), ", ", value -> value == null || value.equals("NULL") ? "NULL" : "\'" + value + "\'");
		final String duplicateUpdate = Common.join(columsAndValues.entrySet(), ", ", entry -> entry.getKey() + "=VALUES(" + entry.getKey() + ")");
		this.update("INSERT INTO " + this.replaceVariables(table) + " (" + columns + ") VALUES (" + values + ") ON DUPLICATE KEY UPDATE " + duplicateUpdate + ";");
	}

	/**
	 * Insert the batch map into {@link #getTable()}
	 *
	 * @param maps
	 */
	protected final void insertBatch(@NonNull List<SerializedMap> maps) {
		if (maps == null) {
			throw new java.lang.NullPointerException("maps is marked non-null but is null");
		}
		this.insertBatch("{table}", maps);
	}

	/**
	 * Insert the batch map into the database
	 *
	 * @param table
	 * @param maps
	 */
	protected final void insertBatch(String table, @NonNull List<SerializedMap> maps) {
		if (maps == null) {
			throw new java.lang.NullPointerException("maps is marked non-null but is null");
		}
		final List<String> sqls = new ArrayList<>();
		for (final SerializedMap map : maps) {
			final String columns = Common.join(map.keySet());
			final String values = Common.join(map.values(), ", ", this::parseValue);
			final String duplicateUpdate = Common.join(map.entrySet(), ", ", entry -> entry.getKey() + "=VALUES(" + entry.getKey() + ")");
			sqls.add("INSERT INTO " + table + " (" + columns + ") VALUES (" + values + ") ON DUPLICATE KEY UPDATE " + duplicateUpdate + ";");
		}
		this.batchUpdate(sqls);
	}

	/*
	 * A helper method to insert compatible value to db
	 */
	private final String parseValue(Object value) {
		return value == null || value.equals("NULL") ? "NULL" : "\'" + SerializeUtil.serialize(Mode.YAML, value).toString() + "\'";
	}

	/**
	 * Attempts to execute a new update query
	 * <p>
	 * Make sure you called connect() first otherwise an error will be thrown
	 *
	 * @param sql
	 */
	protected final void update(String sql) {
		if (!this.connecting) Valid.checkAsync("Updating database must be done async! Call: " + sql);
		this.checkEstablished();
		if (!this.isConnected()) this.connectUsingLastCredentials();
		sql = this.replaceVariables(sql);
		Valid.checkBoolean(!sql.contains("{table}"), "Table not set! Either use connect() method that specifies it or call addVariable(table, \'yourtablename\') in your constructor!");
		Debugger.debug("mysql", "Updating database with: " + sql);
		try (Statement statement = this.connection.createStatement()) {
			statement.executeUpdate(sql);
		} catch (final SQLException e) {
			this.handleError(e, "Error on updating database with: " + sql);
		}
	}

	/**
	 * Lists all rows in the given table with the "*" parameter, listing all rows
	 *
	 * @param table
	 * @param consumer
	 */
	protected final void selectAll(String table, ResultReader consumer) {
		this.select(table, "*", consumer);
	}

	/**
	 * Lists all rows in the given table with the given parameter.
	 * Do not forget to close the connection when done in your consumer.
	 *
	 * @param table
	 * @param param
	 * @param consumer
	 */
	protected final void select(String table, String param, ResultReader consumer) {
		if (!this.isLoaded()) return;
		try (ResultSet resultSet = this.query("SELECT " + param + " FROM " + table)) {
			while (resultSet.next()) try {
				consumer.accept(resultSet);
			} catch (final Throwable t) {
				Common.log("Error reading a row from table " + table + " with param \'" + param + "\', aborting...");
				t.printStackTrace();
				break;
			}
		} catch (final Throwable t) {
			Common.error(t, "Error selecting rows from table " + table + " with param \'" + param + "\'");
		}
	}

	/**
	 * Returns the amount of rows from the given table per the key-value conditions.
	 *
	 * Example conditions: count("MyTable", "Player", "kangarko, "Status", "PENDING")
	 * This example will return all rows where column Player is equal to kangarko and Status column equals PENDING.
	 *
	 * @param table
	 * @param array
	 * @return
	 */
	protected final int count(String table, Object... array) {
		return this.count(table, SerializedMap.ofArray(array));
	}

	/**
	 * Returns the amount of rows from the given table per the conditions,
	 *
	 * Example conditions: SerializedMap.ofArray("Player", "kangarko, "Status", "PENDING")
	 * This example will return all rows where column Player is equal to kangarko and Status column equals PENDING.
	 *
	 * @param table
	 * @param conditions
	 * @return
	 */
	protected final int count(String table, SerializedMap conditions) {
		// Convert conditions into SQL syntax
		final Set<String> conditionsList = Common.convertSet(conditions.entrySet(), entry -> entry.getKey() + " = \'" + SerializeUtil.serialize(Mode.YAML, entry.getValue()) + "\'");
		// Run the query
		final String sql = "SELECT * FROM " + table + (conditionsList.isEmpty() ? "" : " WHERE " + String.join(" AND ", conditionsList)) + ";";
		try (ResultSet resultSet = this.query(sql)) {
			int count = 0;
			while (resultSet.next()) count++;
			return count;
		} catch (final SQLException ex) {
			Common.throwError(ex, "Unable to count rows!", "Table: " + this.replaceVariables(table), "Conditions: " + conditions, "Query: " + sql);
		}
		return 0;
	}

	/**
	 * Attempts to execute a new query
	 * <p>
	 * Make sure you called connect() first otherwise an error will be thrown
	 *
	 * @param sql
	 * @return
	 */
	protected final ResultSet query(String sql) {
		Valid.checkAsync("Sending database query must be called async, command: " + sql);
		this.checkEstablished();
		if (!this.isConnected()) this.connectUsingLastCredentials();
		sql = this.replaceVariables(sql);
		Debugger.debug("mysql", "Querying database with: " + sql);
		try {
			final Statement statement = this.connection.createStatement();
			final ResultSet resultSet = statement.executeQuery(sql);
			return resultSet;
		} catch (final SQLException ex) {
			if (ex instanceof SQLSyntaxErrorException && ex.getMessage().startsWith("Table") && ex.getMessage().endsWith("doesn\'t exist")) return new DummyResultSet();
			this.handleError(ex, "Error on querying database with: " + sql);
		}
		return null;
	}

	/**
	 * Executes a massive batch update
	 *
	 * @param sqls
	 */
	protected final void batchUpdate(@NonNull List<String> sqls) {
		if (sqls == null) {
			throw new java.lang.NullPointerException("sqls is marked non-null but is null");
		}
		if (sqls.isEmpty()) return;
		this.checkEstablished();
		if (!this.isConnected()) this.connectUsingLastCredentials();
		try (Statement batchStatement = this.getConnection().createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
			final int processedCount = sqls.size();
			for (final String sql : sqls) batchStatement.addBatch(this.replaceVariables(sql));
			if (processedCount > 10000) Common.log("Updating your database (" + processedCount + " entries)... PLEASE BE PATIENT THIS WILL TAKE " + (processedCount > 50000 ? "10-20 MINUTES" : "5-10 MINUTES") + " - If server will print a crash report, ignore it, update will proceed.");
			// Prevent automatically sending db instructions
			this.getConnection().setAutoCommit(false);
			try {
				// Execute
				batchStatement.executeBatch();
				// This will block the thread
				this.getConnection().commit();
			} catch (final Throwable t) {
				// Cancel the task but handle the error upstream
				throw t;
			}
		} catch (final Throwable t) {
			final List<String> errorLog = new ArrayList<>();
			errorLog.add(Common.consoleLine());
			errorLog.add(" [" + TimeUtil.getFormattedDateShort() + "] Failed to save batch sql, please contact the plugin author with this file content: " + t);
			errorLog.add(Common.consoleLine());
			for (final String statement : sqls) errorLog.add(this.replaceVariables(statement));
			FileUtil.write("sql-error.log", sqls);
			t.printStackTrace();
		} finally {
			try {
				this.getConnection().setAutoCommit(true);
			} catch (final SQLException ex) {
				ex.printStackTrace();
			}
		}
	}

	/**
	 * Attempts to return a prepared statement
	 * <p>
	 * Make sure you called connect() first otherwise an error will be thrown
	 *
	 * @param sql
	 * @return
	 * @throws SQLException
	 */
	protected final java.sql.PreparedStatement prepareStatement(String sql) throws SQLException {
		this.checkEstablished();
		if (!this.isConnected()) this.connectUsingLastCredentials();
		sql = this.replaceVariables(sql);
		Debugger.debug("mysql", "Preparing statement: " + sql);
		return this.connection.prepareStatement(sql);
	}

	/**
	 * Attempts to return a prepared statement
	 * <p>
	 * Make sure you called connect() first otherwise an error will be thrown
	 *
	 * @param sql
	 * @param type
	 * @param concurrency
	 *
	 * @return
	 * @throws SQLException
	 */
	protected final java.sql.PreparedStatement prepareStatement(String sql, int type, int concurrency) throws SQLException {
		this.checkEstablished();
		if (!this.isConnected()) this.connectUsingLastCredentials();
		sql = this.replaceVariables(sql);
		Debugger.debug("mysql", "Preparing statement: " + sql);
		return this.connection.prepareStatement(sql, type, concurrency);
	}

	/**
	 * Is the connection established, open and valid?
	 * Performs a blocking ping request to the database
	 *
	 * @return whether the connection driver was set
	 */
	protected final boolean isConnected() {
		if (!this.isLoaded()) return false;
		try {
			if (!this.connection.isValid(0)) return false;
		} catch (SQLException | AbstractMethodError err) {
		}
		// Pass through silently
		try {
			return !this.connection.isClosed();
		} catch (final SQLException ex) {
			return false;
		}
	}

	/*
	 * Checks if there's a collation-related error and prints warning message for the user to
	 * update his database.
	 */
	private void handleError(Throwable t, String fallbackMessage) {
		if (t.toString().contains("Unknown collation")) {
			Common.log("You need to update your database provider driver. We switched to support unicode using 4 bits length because the previous system only supported 3 bits.");
			Common.log("Some characters such as smiley or Chinese are stored in 4 bits so they would crash the 3-bit database leading to more problems. Most hosting providers have now widely adopted the utf8mb4_unicode_520_ci encoding you seem lacking. Disable database connection or update your driver to fix this.");
		} else if (t.toString().contains("Incorrect string value")) {
			Common.log("Attempted to save unicode letters (e.g. coors) to your database with invalid encoding, see https://stackoverflow.com/a/10959780 and adjust it. MariaDB may cause issues, use MySQL 8.0 for best results.");
			t.printStackTrace();
		} else Common.throwError(t, fallbackMessage);
	}

	// --------------------------------------------------------------------
	// Non-blocking checking
	// --------------------------------------------------------------------
	/**
	 * Return if the developer called {@link #addVariable(String, String)} early enough
	 * to be registered
	 *
	 * @param key
	 * @return
	 */
	final boolean hasVariable(String key) {
		return this.sqlVariables.containsKey(key);
	}

	/**
	 * Return the table from last connection, throwing an error if never connected
	 *
	 * @return
	 */
	protected final String getTable() {
		this.checkEstablished();
		return Common.getOrEmpty(this.lastCredentials.table);
	}

	/**
	 * Checks if the connect() function was called
	 */
	private final void checkEstablished() {
		Valid.checkBoolean(this.isLoaded(), "Connection was never established, did you call connect() on " + this + "? Use isLoaded() to check.");
	}

	/**
	 * Return true if the connect function was called so that the driver was loaded
	 *
	 * @return
	 */
	public final boolean isLoaded() {
		return this.connection != null;
	}

	// --------------------------------------------------------------------
	// Variables
	// --------------------------------------------------------------------
	/**
	 * Adds a new variable you can then use in your queries.
	 * The variable name will be added {} brackets automatically.
	 *
	 * @param name
	 * @param value
	 */
	protected final void addVariable(final String name, final String value) {
		this.sqlVariables.put(name, value);
	}

	/**
	 * Replace the {table} and {@link #sqlVariables} in the sql query
	 *
	 * @param sql
	 * @return
	 */
	protected final String replaceVariables(String sql) {
		for (final Entry<String, String> entry : this.sqlVariables.entrySet()) sql = sql.replace("{" + entry.getKey() + "}", entry.getValue());
		return sql.replace("{table}", this.getTable());
	}

	// --------------------------------------------------------------------
	// Classes
	// --------------------------------------------------------------------
	/**
	 * Helps to create new database tables preventing SQL syntax errors
	 */
	protected static final class TableCreator {
		/**
		 * The table name
		 */
		private final String name;
		/**
		 * The table columns
		 */
		private final List<TableRow> columns = new ArrayList<>();
		/**
		 * The primary column
		 */
		private String primaryColumn;

		/**
		 * Add a new column of the given name and data type
		 *
		 * @param name
		 * @param dataType
		 * @return
		 */
		public TableCreator add(String name, String dataType) {
			this.columns.add(TableRow.builder().name(name).dataType(dataType).build());
			return this;
		}

		/**
		 * Add a new column of the given name and data type that is "NOT NULL"
		 *
		 * @param name
		 * @param dataType
		 * @return
		 */
		public TableCreator addNotNull(String name, String dataType) {
			this.columns.add(TableRow.builder().name(name).dataType(dataType).notNull(true).build());
			return this;
		}

		/**
		 * Add a new column of the given name and data type that is "NOT NULL AUTO_INCREMENT"
		 *
		 * @param name
		 * @param dataType
		 * @return
		 */
		public TableCreator addAutoIncrement(String name, String dataType) {
			this.columns.add(TableRow.builder().name(name).dataType(dataType).autoIncrement(true).build());
			return this;
		}

		/**
		 * Add a new column of the given name and data type that has a default value
		 *
		 * @param name
		 * @param dataType
		 * @param def
		 * @return
		 */
		public TableCreator addDefault(String name, String dataType, String def) {
			this.columns.add(TableRow.builder().name(name).dataType(dataType).defaultValue(def).build());
			return this;
		}

		/**
		 * Marks which column is the primary key
		 *
		 * @param primaryColumn
		 * @return
		 */
		public TableCreator setPrimaryColumn(String primaryColumn) {
			this.primaryColumn = primaryColumn;
			return this;
		}

		/**
		 * Create a new table
		 *
		 * @param name
		 * @return
		 */
		public static TableCreator of(String name) {
			return new TableCreator(name);
		}

		/**
		 * The table name
		 */
		@java.lang.SuppressWarnings("all")
		public String getName() {
			return this.name;
		}

		/**
		 * The table columns
		 */
		@java.lang.SuppressWarnings("all")
		public List<TableRow> getColumns() {
			return this.columns;
		}

		/**
		 * The primary column
		 */
		@java.lang.SuppressWarnings("all")
		public String getPrimaryColumn() {
			return this.primaryColumn;
		}

		@java.lang.SuppressWarnings("all")
		public TableCreator(final String name) {
			this.name = name;
		}
	}

	/*
	 * Internal helper to create table rows
	 */
	private static final class TableRow {
		/**
		 * The table row name
		 */
		private final String name;
		/**
		 * The data type
		 */
		private final String dataType;
		/**
		 * Is this row NOT NULL?
		 */
		private final Boolean notNull;
		/**
		 * Does this row have a default value?
		 */
		private final String defaultValue;
		/**
		 * Is this row NOT NULL AUTO_INCREMENT?
		 */
		private final Boolean autoIncrement;

		@java.lang.SuppressWarnings("all")
		TableRow(final String name, final String dataType, final Boolean notNull, final String defaultValue, final Boolean autoIncrement) {
			this.name = name;
			this.dataType = dataType;
			this.notNull = notNull;
			this.defaultValue = defaultValue;
			this.autoIncrement = autoIncrement;
		}


		@java.lang.SuppressWarnings("all")
		public static class TableRowBuilder {
			@java.lang.SuppressWarnings("all")
			private String name;
			@java.lang.SuppressWarnings("all")
			private String dataType;
			@java.lang.SuppressWarnings("all")
			private Boolean notNull;
			@java.lang.SuppressWarnings("all")
			private String defaultValue;
			@java.lang.SuppressWarnings("all")
			private Boolean autoIncrement;

			@java.lang.SuppressWarnings("all")
			TableRowBuilder() {
			}

			/**
			 * The table row name
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings("all")
			public SimpleDatabase.TableRow.TableRowBuilder name(final String name) {
				this.name = name;
				return this;
			}

			/**
			 * The data type
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings("all")
			public SimpleDatabase.TableRow.TableRowBuilder dataType(final String dataType) {
				this.dataType = dataType;
				return this;
			}

			/**
			 * Is this row NOT NULL?
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings("all")
			public SimpleDatabase.TableRow.TableRowBuilder notNull(final Boolean notNull) {
				this.notNull = notNull;
				return this;
			}

			/**
			 * Does this row have a default value?
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings("all")
			public SimpleDatabase.TableRow.TableRowBuilder defaultValue(final String defaultValue) {
				this.defaultValue = defaultValue;
				return this;
			}

			/**
			 * Is this row NOT NULL AUTO_INCREMENT?
			 * @return {@code this}.
			 */
			@java.lang.SuppressWarnings("all")
			public SimpleDatabase.TableRow.TableRowBuilder autoIncrement(final Boolean autoIncrement) {
				this.autoIncrement = autoIncrement;
				return this;
			}

			@java.lang.SuppressWarnings("all")
			public SimpleDatabase.TableRow build() {
				return new SimpleDatabase.TableRow(this.name, this.dataType, this.notNull, this.defaultValue, this.autoIncrement);
			}

			@java.lang.Override
			@java.lang.SuppressWarnings("all")
			public java.lang.String toString() {
				return "SimpleDatabase.TableRow.TableRowBuilder(name=" + this.name + ", dataType=" + this.dataType + ", notNull=" + this.notNull + ", defaultValue=" + this.defaultValue + ", autoIncrement=" + this.autoIncrement + ")";
			}
		}

		@java.lang.SuppressWarnings("all")
		public static SimpleDatabase.TableRow.TableRowBuilder builder() {
			return new SimpleDatabase.TableRow.TableRowBuilder();
		}

		/**
		 * The table row name
		 */
		@java.lang.SuppressWarnings("all")
		public String getName() {
			return this.name;
		}

		/**
		 * The data type
		 */
		@java.lang.SuppressWarnings("all")
		public String getDataType() {
			return this.dataType;
		}

		/**
		 * Is this row NOT NULL?
		 */
		@java.lang.SuppressWarnings("all")
		public Boolean getNotNull() {
			return this.notNull;
		}

		/**
		 * Does this row have a default value?
		 */
		@java.lang.SuppressWarnings("all")
		public String getDefaultValue() {
			return this.defaultValue;
		}

		/**
		 * Is this row NOT NULL AUTO_INCREMENT?
		 */
		@java.lang.SuppressWarnings("all")
		public Boolean getAutoIncrement() {
			return this.autoIncrement;
		}

		@java.lang.Override
		@java.lang.SuppressWarnings("all")
		public boolean equals(final java.lang.Object o) {
			if (o == this) return true;
			if (!(o instanceof SimpleDatabase.TableRow)) return false;
			final SimpleDatabase.TableRow other = (SimpleDatabase.TableRow) o;
			final java.lang.Object this$notNull = this.getNotNull();
			final java.lang.Object other$notNull = other.getNotNull();
			if (this$notNull == null ? other$notNull != null : !this$notNull.equals(other$notNull)) return false;
			final java.lang.Object this$autoIncrement = this.getAutoIncrement();
			final java.lang.Object other$autoIncrement = other.getAutoIncrement();
			if (this$autoIncrement == null ? other$autoIncrement != null : !this$autoIncrement.equals(other$autoIncrement)) return false;
			final java.lang.Object this$name = this.getName();
			final java.lang.Object other$name = other.getName();
			if (this$name == null ? other$name != null : !this$name.equals(other$name)) return false;
			final java.lang.Object this$dataType = this.getDataType();
			final java.lang.Object other$dataType = other.getDataType();
			if (this$dataType == null ? other$dataType != null : !this$dataType.equals(other$dataType)) return false;
			final java.lang.Object this$defaultValue = this.getDefaultValue();
			final java.lang.Object other$defaultValue = other.getDefaultValue();
			if (this$defaultValue == null ? other$defaultValue != null : !this$defaultValue.equals(other$defaultValue)) return false;
			return true;
		}

		@java.lang.Override
		@java.lang.SuppressWarnings("all")
		public int hashCode() {
			final int PRIME = 59;
			int result = 1;
			final java.lang.Object $notNull = this.getNotNull();
			result = result * PRIME + ($notNull == null ? 43 : $notNull.hashCode());
			final java.lang.Object $autoIncrement = this.getAutoIncrement();
			result = result * PRIME + ($autoIncrement == null ? 43 : $autoIncrement.hashCode());
			final java.lang.Object $name = this.getName();
			result = result * PRIME + ($name == null ? 43 : $name.hashCode());
			final java.lang.Object $dataType = this.getDataType();
			result = result * PRIME + ($dataType == null ? 43 : $dataType.hashCode());
			final java.lang.Object $defaultValue = this.getDefaultValue();
			result = result * PRIME + ($defaultValue == null ? 43 : $defaultValue.hashCode());
			return result;
		}

		@java.lang.Override
		@java.lang.SuppressWarnings("all")
		public java.lang.String toString() {
			return "SimpleDatabase.TableRow(name=" + this.getName() + ", dataType=" + this.getDataType() + ", notNull=" + this.getNotNull() + ", defaultValue=" + this.getDefaultValue() + ", autoIncrement=" + this.getAutoIncrement() + ")";
		}
	}


	/**
	 * A helper class to read results set. (We cannot use a simple Consumer since it does not
	 * catch exceptions automatically.)
	 */
	protected interface ResultReader {
		/**
		 * Reads and process the given results set, we handle exceptions for you
		 *
		 * @param set
		 * @throws SQLException
		 */
		void accept(ResultSet set) throws SQLException;
	}


	/**
	 * Stores last known credentials from the connect() functions
	 */
	private final class LastCredentials {
		/**
		 * The connecting URL, for example:
		 * <p>
		 * jdbc:mysql://host:port/database
		 */
		private final String url;
		/**
		 * The user name for the database
		 */
		private final String user;
		/**
		 * The password for the database
		 */
		private final String password;
		/**
		 * The table. Never used in this class, only stored for your convenience
		 */
		private final String table;

		@java.lang.SuppressWarnings("all")
		public LastCredentials(final String url, final String user, final String password, final String table) {
			this.url = url;
			this.user = user;
			this.password = password;
			this.table = table;
		}
	}

	/**
	 * The established connection, or null if none
	 */
	@java.lang.SuppressWarnings("all")
	protected Connection getConnection() {
		return this.connection;
	}
}
